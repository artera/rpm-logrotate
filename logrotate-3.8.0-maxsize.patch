Index: logrotate.c
===================================================================
--- logrotate.c	(revision 336)
+++ logrotate.c	(working copy)
@@ -786,6 +786,8 @@
 	}
 	if (log->minsize && sb.st_size < log->minsize)
 	    state->doRotate = 0;
+	if (log->maxsize && sb.st_size > log->maxsize)
+	    state->doRotate = 1;
     }
 
     /* The notifempty flag overrides the normal criteria */
@@ -1465,6 +1467,9 @@
     if (log->minsize) 
 	message(MESS_DEBUG, "only log files >= %llu bytes are rotated, ",	log->minsize);
 
+    if (log->maxsize) 
+	message(MESS_DEBUG, "log files >= %llu are rotated earlier, ",	log->minsize);
+
     if (log->logAddress) {
 	message(MESS_DEBUG, "old logs mailed to %s\n", log->logAddress);
     } else {
Index: logrotate.h
===================================================================
--- logrotate.h	(revision 336)
+++ logrotate.h	(working copy)
@@ -36,6 +36,7 @@
     enum { ROT_DAYS, ROT_WEEKLY, ROT_MONTHLY, ROT_YEARLY, ROT_SIZE,
 	    ROT_FORCE } criterium;
     unsigned long long threshhold;
+	unsigned long long maxsize;
     unsigned long long minsize;
     int rotateCount;
     int rotateAge;
Index: config.c
===================================================================
--- config.c	(revision 336)
+++ config.c	(working copy)
@@ -290,6 +290,7 @@
     to->criterium = from->criterium;
     to->threshhold = from->threshhold;
     to->minsize = from->minsize;
+	to->maxsize = from->maxsize;
     to->rotateCount = from->rotateCount;
     to->rotateAge = from->rotateAge;
     to->logStart = from->logStart;
@@ -504,6 +505,7 @@
 		.criterium = ROT_SIZE,
 		.threshhold = 1024 * 1024,
 		.minsize = 0,
+		.maxsize = 0,
 		.rotateCount = 0,
 		.rotateAge = 0,
 		.logStart = -1,
@@ -885,7 +887,8 @@
 					newlog->flags |= LOG_FLAG_CREATE;
 				} else if (!strcmp(key, "nocreate")) {
 					newlog->flags &= ~LOG_FLAG_CREATE;
-				} else if (!strcmp(key, "size") || !strcmp(key, "minsize")) {
+				} else if (!strcmp(key, "size") || !strcmp(key, "minsize") ||
+							!strcmp(key, "maxsize")) {
 					unsigned long long size = 0;
 					char *opt = key;
 							
@@ -930,6 +933,8 @@
 						if (!strncmp(opt, "size", 4)) {
 						  newlog->criterium = ROT_SIZE;
 						  newlog->threshhold = size;
+						} else if (!strncmp(opt, "maxsize", 7)) {
+						  newlog->maxsize = size;
 						} else {
 						  newlog->minsize = size;
 						}
Index: logrotate.8
===================================================================
--- logrotate.8	(revision 336)
+++ logrotate.8	(working copy)
@@ -285,7 +285,17 @@
 configured address if \fBmaillast\fR and \fBmail\fR are configured.
 
 .TP
-\fBminsize\fR \fIsize\fR
+\fBmaxsize\fR \fIsize\fR
+Log files are rotated when they grow bigger than \fIsize\fR bytes even
+before the additionally specified time interval (\fBdaily\fR, \fBweekly\fR,
+\fBmonthly\fR, or \fByearly\fR).  The related \fBsize\fR option is similar
+except that it is mutually exclusive with the time interval options, and it
+causes log files to be rotated without regard for the last rotation time.
+When \fBmaxsize\fR is used, both the size and timestamp of a log file are
+considered.
+
+.TP
+\fBminsize\fR  \fIsize\fR
 Log files are rotated when they grow bigger than \fIsize\fR bytes, but not
 before the additionally specified time interval (\fBdaily\fR, \fBweekly\fR,
 \fBmonthly\fR, or \fByearly\fR).  The related \fBsize\fR option is similar
